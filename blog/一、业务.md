## 一、业务

#### 1、基木鱼业务的架构

基木鱼分为B端、C端、D端。其中



D端：



 D端主要是给FE上传一些组件，模板使用的，组件与模板上传以后要经过审核，发布，才能在B端使用（B端在新建营销页的时候，最左侧有组件列表根据不同的产品线获取不同的组件信息）。



B端：



 B端业务主要面向广告主，包括营销页面的创建，审核与发布，数据报告的生成与查看等，营销页主要分为智能单页、多页站点、文章页、行业定制，采用编辑器的方式设计营销页，同时提供大量的模板供用户使用，页面审核通过后进行投放，投放以后用户可以在C端看到页面。帮助广告主简单、快速搭建广告推广落地页，海量丰富的行业模板，可帮助广告主快速搭建多类型落地页，满足不同场景下的不同推广需求。包括基木鱼平台和编辑器，主要提供页面的制作功能（站点/页面管理、模板、页面送审），页面制作完毕以后会生成页面结构的pageconfig。



C端：



 C端业务主要面向网民，包括营销页面的编译和渲染。拿到B端的pageconfig文件进行编译渲染，生成对应的C端页面。



![image-20210416153803482](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-e2b06a4f706b52cfbac2c0069b7b2a201395590a)



#### 2、业务的理解

![image-20210419205342202](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-ed58288140875da706c862d631035ed3ac4fbc03)



基木鱼平台主要是为广告主提供免费的建站能力，帮助广告主能够快速搭建丰富的广告阵地，满足广告主不同的营销内容和生产需求。能够支持H5、小程序等多种落地页类型。能够和用户快速的建立连接，通过营销通来实现多维度的线索沉淀运营。



基木鱼平台的整体流程大致如下图，广告主可以在基木鱼平台定制小程序、H5、PC三种类型的托管页面，在制作过程中可以使用C端提供的一些组件，页面定制完成以后页面结构会通过pageconfig的形式发送给后端，后端会对关键数据进行存储，进行风险控制，通过了风控检验的网页作为托管页投放到凤巢、feed等地方给网民看。



凤巢是**搜索推广**，feed是**信息流推广**。



**搜索推广**



用户是要主动去找东西或者项目才可能搜索到你网站或信息，虽然成交率更高些，但是消费比较高。



**信息流推广**



系统主动去找客户，系统会根据你平时的搜索习惯，主动推荐给客户信息，客户也许有多种习惯，而这个习惯范围太广，也就是说推广的客户可能不太精准。





#### 3、业务流

![<img src="/Users/gaoxi03/Library/Application Support/typora-user-images/image-20210418165241144.png" alt="image-20210418165241144" style="zoom:50%;" />](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-19487fd55b23357671dd1dbba5fba7e2d261a26c)



| 名词     | 解释                                                         |
| :------- | :----------------------------------------------------------- |
| bfe      | 百度统一前端接入和转发，全局流量调度，安全和防攻击，数据分析 |
| hairuo   | 流量转发，统一管理API元信息和文档                            |
| jeep     | 梧桐后端模块，负责站点增删改查等                             |
| ironman  | 建站中台，负责站点增删改查、审核、编译推送、各种通用api等    |
| benz     | 后端编译渲染模块                                             |
| spideman | 前端编译模块（pageConfig（json）—>html）                     |

备注BFE：BFE最初是Baidu Front End的缩写（中文名为“百度统一前端”），是百度统一的七层负载均衡接入转发平台。BFE平台
从2012年开始建设。截至2020年底，BFE平台每日转发的请求超过1万亿，日峰值请求超过1000万QPS。
2019年7月，BFE的转发引1擎对外开源。因为BFE项目在业界的巨大影响力，开源项目名称仍保持为BFE，但改名为
Beyond Front End。 希望通过BFE的开源，能够推动负载均衡技术的发展。



B端页面编译流：



客户在编辑器中完成了页面的制作，根据页面结构制作出pageconfig，通过bfe进行转发到hairuo，hairuo是一个API接口平台，主要负责流量的转发，通过hairuo到达后端jeep，然后传递到建站中台ironman，ironman将页面信息存储到数据库中，通过benz进行编译渲染操作，编译完成后调用spiderman解析pageconfig，拼串生成html的字符串，然后将其存储在redis库中等待url的get请求。



## 二、开发

#### 1、开发流程的理解

![image-20210416141609895](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-b0237169a99b61ef6be67c0f1e9e438466bf0096)



#### 2、pageconfig caselist评审 小流量上线 加名单 全量上线

pageConfig是一个可以描述C端页面内容的json数据。



B端编辑器保存生成的是一段pageConfig，C端拿到pageConfig进行编译渲染，生成对应的C端页面。



![image-20210419205311892](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-7a82d032c736c69e26816fcc45805254c93dfe44)



widgets: 组件加内容块信息



pageModuleIds：内容块索引list



```
{    /* 其他信息先省略 */    "siteName": "xxxxx",    "pageType": 0,    "extData": {        "pageStyle": {            "mLayout": {                "paddingBottom":45,                "paddingTop": 30            }        },        "paddingTop": 0,        "paddingBottom": 0    },    "pageModuleIds": [        0,        2    ],    "widgets": [        {            "title": "内容块组件",            "widgetMoldName": "module",            "name": "mip-sjh-module",            "child": [                1            ],            /* 内容块组件其他信息省略 */        },        {            "name": "mip-sjh-img-single",            "title": "单图",            "properties": {/*单图组件properties信息省略*/},            "child": [],            /* 单图组件其他信息省略 */        },        {            "title": "内容块组件",            "widgetMoldName": "module",            "name": "mip-sjh-module",            "child": [                3            ],            "properties": {                "backgroundColor": "",                "backgroundImg": "",                "mSizeHeight": 171            },            /* 内容块组件其他信息省略 */        },        {            "name": "mip-sjh-text-content",            "title": "文字",            "properties": {/*文字组件properties信息省略*/},            "widgetMoldName": "text-content",            "mLayout": {                "isBlock": false,                "fixed": false            },            "thumbnail": "https://imagelib.cdn.bcebos.com/cip_ml_pic7c0f3e7f-209d-4ce3-931e-ab9549d4e3d3.png",            "child": [],            /* 文字组件其他信息省略 */        }    ]}
```

页面中渲染哪些内容，先从`pageModuleIds`字段查找，`pageModuleIds`数组的每一项对应`widgets`字段的索引。如下结构里pageModuleIds为`[0, 2]`。对应按序渲染`widgets[0]`，`widgets[2]`组件，第一级渲染的这两个组件一定是`内容块组件`。`widgets[0].child`与`widgets[2].child`字段也是对应widgets字段的索引数组，渲染每个内容块里的子组件。



#### 3、C端组件

C端组件可以分为H5、PC组件。



##### 3.1 工程架构：

**src/components，src/funcs，src/modules目录的组件可以在D端发布**



- components里面放的是复用性高，功能相对收敛的组件（可以直接拖进编辑器的、可以供其他组件使用的基础组件）
- funcs 不涉及UI的业务逻辑复杂度高的（mip-sjh-basic-download）
- modules 业务复杂的几乎没有通用性的的组件
- 

##### 3.2 组件结构

![<img src="/Users/gaoxi03/Library/Application Support/typora-user-images/image-20210419154419613.png" alt="image-20210419154419613" style="zoom:67%;" />](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-b583072f51bf1b9a4848becbff6065a3ec8ccc51)



其中：



- index.vue 组件入口文件
- mold.js 工程文件，定义依赖等信息，相当于mold.json
- props.js工程文件， 定义组件的props属性，这些属性会被注入到组件的properties属性中
- schema.js 工程文件，定义对props的约束属性，进行校验
- defaultProperties 定义默认的props属性
- 

可以在depWidgets中定义强依赖组件，在registedAsyncComponent()函数用来动态加载依赖。



##### 3.3 需求

收敛前的动态组件中只有在焦点图中有角标展示，收敛后除了双列没有角标，其他都可以添加角标样式。



添加角标的props属性



```
'corner-content': {        'isShow': true,        'type': '2',        'dynamicTitle': {},        'staticTitle': 'HOT',        'cornerStyle': {            'backgroundColor': '#E6322E',            'fontColor': '#fff'        } },
```

很多组件都涉及到角标的样式，因此把对角标的操作提到公共的common中



```
                mark() {            const {cornerContent = {}} = this.contents;            const {isShow, type, dynamicTitle, staticTitle} = cornerContent;            if (!isShow) {                return null;            }            if (isDynamic(type)) { // 动态文案                return getDynamicValue(dynamicTitle, this.dataItem.dynamicFields);            }            if (isStatic(type)) { // 固定文案                return staticTitle;            }            if (type === '2') { // 默认                const extraIndex = ['foucus-cross', 'novel'].includes(this.compType) ? 0 : 1;                return `TOP${this.index + extraIndex}`;            }            return null;        },        markStyle() {            const {cornerContent = {}} = this.contents;            const {backgroundColor = '#FF7033', fontColor = '#FFF'} = cornerContent.cornerStyle || {};            return {                background: MARK_STYLE_CONFIG[backgroundColor],                color: fontColor            };        },
```

#### 4、B端编辑器

##### 4.1 主要功能区域

编辑器主要分为四个部分左侧列表区、中间画布区、右侧编辑区、以及顶部的操作区



![<img src="/Users/gaoxi03/Library/Application Support/typora-user-images/image-20210418233723100.png" alt="image-20210418233723100" style="zoom:50%;" />](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-bb3952850e124ae89ecec153b3303bc95e345879)



左侧列表区是通过jianzhan_v2_widget_get_widget-mold获得，及获取其中的映射关系。（注意moldGroup、groupId、parentId需要保持一致 ，moldGroupId， widgetMoldGroupId，widgetMoldId需保证唯一性；）



```
{    "moldGroupId": 96,    "moldGroupName": "动态组件",    "parentId": 0,    "moldGroupDesc": "",    "layerIcon": "https://imagelib.cdn.bcebos.com/cip_ml_pic443e6b6e-609a-456c-a228-52ec806b495b.png",    "layerName": "动态商品组件",    "moldGroupTag": "",    "children": [        {            "moldGroupId": 97,            "moldGroupName": "图文商品",            "parentId": 96,            "moldGroupDesc": "",            "layerIcon": "https://imagelib.cdn.bcebos.com/cip_ml_pic0c8b1a27-0891-4e3b-981b-1d56c353cb41.png",            "layerName": "图文商品",            "moldGroupTag": "",            "children": []        },        {            "moldGroupId": 124,            "moldGroupName": "视频商品",            "parentId": 96,            "moldGroupDesc": "",            "layerIcon": "",            "layerName": "",            "moldGroupTag": "",            "children": []        }    ]}
{    "widgetId": 274,    "name": "mip-sjh-dynamic-goods",    "title": "动态图文",    "type": "mip-sjh-dynamic-goods",    "groupId": 44,    "groupName": "基本样式",    "icon": "w-icon-mip-sjh-dynamic-goods",    "doc": "{}",    "bizType": [        4000    ],    "widgetUrl": "https://duzhanread.cdn.bcebos.com/jianzhan_widget/online_loki/mip-sjh-dynamic-goods269.js",    "depWidgets": "{\"mip-fixed\":\"https://c.mipcdn.com/static/v1/mip-fixed/mip-fixed.js\",\"mip-sjh-basis-download\":\"https://duzhanread.cdn.bcebos.com/jianzhan_widget/online_loki/mip-sjh-basis-download269.js\",\"mip-sjh-imlp-sdk\":\"https://duzhanread.cdn.bcebos.com/jianzhan_widget/online_loki/mip-sjh-imlp-sdk99.js\",\"mip-sjh-text\":\"https://duzhanread.cdn.bcebos.com/jianzhan_widget/online_loki/mip-sjh-text99.js\"}",    "properties": "{\"convergence\":true,\"m-version\":\"3.5\",\"system-info\":{\"ios-link\":\"\",\"autoDirectLaunchTime\":5,\"docid\":\"\",\"iosSchema\":\"\",\"iosName\":\"应用名称\",\"iosIcon\":\"\",\"docSize\":\"\",\"doc-link\":\"\",\"iosVersion\":\"\",\"isIntelligentDirectLaunch\":true,\"isDirectLaunch\":false,\"isAutoDirectLaunch\":false,\"docName\":\"应用名称\",\"iosid\":\"\",\"docSchema\":\"\",\"docUrl\":\"\",\"iosSize\":\"\",\"iosUrl\":\"\",\"docVersion\":\"\",\"docIcon\":\"\"},\"__type\":\"novel\",\"mPosY\":{\"changeable\":true,\"value\":0},\"__biz-type__\":[4000],\"mSizeWidth\":{\"changeable\":false,\"value\":375},\"mSizeHeight\":{\"changeable\":false,\"value\":1096},\"m-coordinates\":\"leftTop\",\"mPosX\":{\"changeable\":true,\"value\":0}}",    "widgetMoldId": 3990,    "widgetMoldName": "mip-sjh-dynamic-goods-new-novel",    "mLayout": "{\"isBlock\":true,\"fixed\":false}",    "thumbnail": "https://img2.baidu.com/it/u=1779655133,2327716287&fm=26&fmt=auto&gp=0.jpg",    "widgetMoldGroupId": 181}
```

![<img src="/Users/gaoxi03/Library/Application Support/typora-user-images/image-20210419161600677.png" alt="image-20210419161600677" style="zoom:50%;" />](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-bcfc499f465655a531745308ddae9079da24fccc)



中间的画布及拖拽功能被集成在m-captain(编辑器底层功能模块)里面，读取pageConfig进行渲染页面。



右侧的编辑区是在**src/components/default/editor**中进行配置



##### 4.2 编辑区和画布区的交互

编辑区与画布区的交互的具体实现，一部分封装在了m-captain中，进行B端编辑器开发时，可以使用editorChange事件实现



```
methods: {         handleSimpleTextChange(propName, value) {            this.$emit('editorChange', initEditorData(propName, value), true);        },    }
```

##### 4.3 需求

动态商品收敛后除了双列样式的组件，其他的组件都可以设置角标。



整体的需求可以拆分为下面几个部分



1 . 在商品信息模块添加一个角标选项



![<img src="/Users/gaoxi03/Library/Application Support/typora-user-images/image-20210419165416411.png" alt="image-20210419165416411" style="zoom:50%;" />](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-fd47a34c521b10471e9d0befb20a95e5d5bac5a0)



通过productInfo.ProductCorner的值来判断组件是否展示角标。



```
<product-corner     v-if="productInfo.ProductCorner"     ref="ProductCorner"     :content="cornerContent"     :list="textList"     @editorChange="editorChange"/>
```

2 . 角标的内容设置



![<img src="/Users/gaoxi03/Library/Application Support/typora-user-images/image-20210419163806867.png" alt="image-20210419163806867" style="zoom:40%;" />](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-a0e4a1954a8ec4a454b2971122a5f5800aca95fd)



角标的文案分为动态(0)、固定(1)、排行(2)三种情况。通过判断cornerType的值去渲染对应情况下的页面。



![image-20210419170848434](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-de2b812cefb3c11a522dc557fdd0c8cd468d4f4c)



3 . 错误提示



错误提示又分三种校验：



3 . 1 内容设置模块会判断是否输入文案（固定文案会判断输入长度）



监听文案的content的变化，每次content发生变化的时候就调用validate进行校验



```
 validate() {     this.cornerValidate = validate.cornerContent({cornerContent: this.content}); }
```

![<img src="/Users/gaoxi03/Library/Application Support/typora-user-images/image-20210419171530077.png" alt="image-20210419171530077" style="zoom:50%;" />](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-ab4e8f0ab036dcc91863533a7e11d9c3df2fd1c3)



3 . 2 内容设置模块未选择，商品属性模块报错提示。



![image-20210419171752178](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-0afdc0d3fcfa310155e4c8f086347f4905e69edd)



每一次content发生改变的时候，都进行了校验，并且讲error和errorMsg都保存了下来。此处传入validateError



![<img src="/Users/gaoxi03/Library/Application Support/typora-user-images/image-20210419172812644.png" alt="image-20210419172812644" style="zoom:57%;" />](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-bebdba12ff9eb073d8280c0496a16232a77d9c2c)



3 . 3 内容设置未补充完整，保存时页面错误提示。



![<img src="/Users/gaoxi03/Library/Application Support/typora-user-images/image-20210419183357691.png" alt="image-20210419183357691" style="zoom:67%;" />](http://bos.bj.bce-internal.sdns.baidu.com/agroup-bos-bj/bj-58baeaa61bf2f451d9d3a2d3812ab00ecebc27ed)



页面进行保存操作的时候，会进行一次全局的错误校验。这里采用调用子组件ProductCorner中的validate()函数进行校验。

### 一、为什么需要前端监控

前端监控的目的是：

***获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向***。

前端监控可以分为三类：数据监控、性能监控和异常监控。下面我们来一一的了解。

#### (1)数据监控

数据监控，顾名思义就是监听用户的行为。常见的数据监控包括：

- PV/UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数
- 用户在每一个页面的停留时间
- 用户通过什么入口来访问该网页
- 用户在相应的页面中触发的行为

统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。

#### (2)性能监控

性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：

- 不同用户，不同机型和不同系统下的首屏加载时间
- 白屏时间
- http等请求的响应时间
- 静态资源整体下载时间
- 页面渲染时间
- 页面交互动画完成时间

这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。

#### (3)异常监控

此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：

- Javascript的异常监控
- 样式丢失的异常监控

### 二、常用前端埋点方案总结

在上一节中介绍了前端监控的作用，那么如何实现前端监控呢，实现前端监控的步骤为：前端埋点和上报、数据处理和数据分析。首要的步骤就是前端埋点和上报，也就是数据的收集阶段。数据收集的丰富性和准确性会影响对产品线上效果的判别结果。

目前常见的前端埋点方法分为三种：代码埋点、可视化埋点和无痕埋点。下面一一介绍每一种埋点的方法。

#### (1) 代码埋点

代码埋点，就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接将监听行为以某一种数据格式直接传递给server端。此外比如需要统计产品的PV和UV的时候，需要在网页的初始化时，发送用户的访问信息等。

代码埋点的优点：

- 可以在任意时刻，精确的发送或保存所需要的数据信息。

缺点：

- 工作量较大，每一个组件的埋点都需要添加相应的代码

#### (2)可视化埋点

- 通过可视化交互的手段，代替代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。

  可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。也就是用一个系统来实现手动插入代码埋点的过程。

  缺点：

  - 可视化埋点可以埋点的控件有限，不能手动定制。

#### (3)无埋点

- 通过技术手段无差别地记录用户在前端页面上的行为。可以正确的获取 PV、UV、IP、Action、Time 等信息。

  缺点：前期开发统计基础信息的技术产品成本较高、后期数据分析数据量很大、分析成本较高（大量数据传统的关系型数据库压力大）

  优点：开发人员工作量小、数据全面、无遗漏、产品和运营按需分析、支持动态页面的统计分析

### 三、前端埋点方案选型和前端上报方案设计

第一章中介绍了前端所需要监听的信息，在第二章中介绍了前端埋点的常见方式，本文来根据需求，来定制我们的埋点和上报方案。

#### (1)监控数据

首先我们需要明确一个产品或者网页，普遍需要监控和上报的数据。监控的分为三个阶段：用户进入网页首页、用户在网页内部交互和交互中报错。每一个阶段需要监控和上报的数据如下图所示：



![default](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/2/164fa1642bb839ad~tplv-t2oaga2asx-watermark.awebp)



#### (2)埋点方案

在实际项目中考虑到上报数据的灵活定制，以及减少数据传输和服务器的压力，在所需埋点处不多的情况下，常用的方式是代码埋点。

以用户进入首页为例，我们在首页渲染完成后会发送事件类型和类型相关的数据给server端，告知首页的监控信息。



![default](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/8/2/164fa1642e279de6~tplv-t2oaga2asx-watermark.awebp)



#### (3)上报周期和上报数据类型

如果埋点的事件不是很多，上报可以时时进行，比如监控用户的交互事件，可以在用户触发事件后，立刻上报用户所触发的事件类型。如果埋点的事件较多，或者说网页内部交互频繁，可以通过本地存储的方式先缓存上报信息，然后定期上报。

接着来确定需要埋点上报的数据，上报的信息包括用户个人信息以及用户行为，主要数据可以分为：

- who: appid(系统或者应用的id),userAgent(用户的系统、网络等信息)
- when: timestamp(上报的时间戳)
- from where: currentUrl(用户当前url)，fromUrl(从哪一个页面跳转到当前页面)，type(上报的事件类型),element(触发上报事件的元素）
- what: 上报的自定义扩展数据data:{},扩展数据中可以按需求定制，比如包含uid等信息

上报数据的对象为：

```
{   
    ----------------上报接口本身提供--------------------
    currentUrl,  
    fromUrl,
    timestamp,
    userAgent:{
       os,
       netWord,
    }
    ----------------业务代码配置和自定义上报数据------------
    type,
    appid,
    element,
    data:{
        uid,
        uname
    }
}
复制代码
```

#### (4)埋点和上报举例

我们以上报首屏加载事件为例，DOM提供了document的DOMContentLoaded事件来监听dom挂载，提供了window的load事件来监听页面所有资源加载渲染完毕。

```
<script type="text/javascript">
  var start=Date.now();
  document.addEventListener('DOMContentLoaded', function() {
     fetch('some api',{
         type:'dom complete',
         data:{
           domCompletedTime:Date.now()-start
         }
     })
  });
  window.addEventListener('load', function() {
     fetch('some api',{
         type:'load complete',
         data:{
           LoadCompletedTime:Date.now()-start
         }
     })
  });
</script>
复制代码
```

#### (5)前端埋点系统的前后端通信加密

在上报数据的前后端通信中，需要和server端协商加密机制，利用 OpenSSL库来实现的加密，OpenSSL已经是一个广泛被采用的加密算法。前端可以采用node的crypto模块。

首先来看hash算法，crypto.createHash() 来创建一个Hash实例，可利用的hash算法如下：

- md5
- sha1
- sha256
- sha512
- ripemd160

以sha256算法加密为例：

```
const str="123445";//需要加密的字段
const hash=crypto.createHash('sha256');//指定加密算法
hash.update(str); //通过算法加密相应的字段
const result=hash.digest('hex');//转化成十六进制
复制代码
```

### 四、前端监控结果可视化展示系统的设计

当后端得到前端上报的信息之后，经过数据分析和处理，需要前端可视化的展示数据分析后的结果。

可以在开源中后台系统ant-design-pro的基础上进行二次开发，首先要明确展示信息。展示的信息包括单个用户和整体应用。

对于单个用户来说需要展示的监控信息为：

- 单个用户，在交互过程中触发各个埋点事件的次数
- 单个用户，在某个时间周期内，访问本网页的入口来源
- 单个用户，在每一个子页面的停留时间

对于全体用户需要展示的信息为：

- 某一个时间段内网页的PV和UV
- 全体用户访问网页的设备和操作系统分析
- 某一个时间段内访问本网页的入口来源分析
- 全体用户在访问本网页时，在交互过程中触发各个埋点事件的总次数
- 全体用户在访问本网页时，网页上报异常的集合

删选功能集合：

- 时间筛选：提供今日（00点到当前时间）、本周、本月和全年
- 用户删选：提供根据用户id删选出用户行为的统计信息
- 设备删选：删选不同系统的整体展示信息

## 三、思考和展望

##### 思考

1. 复盘总结，不管是开发还是学习过程中，应该及时对问题复盘总结，并且文档化，积累经验；
2. 在开发的过程中应该贯穿模块化、复用性这种思维；
3. 对需求进行合理的拆分；将大的复杂的需求转换成一个个小的简单的需求，逐个解决。
4. 

##### 展望

1. 能在后续的过程中完整的参与一个项目的开发，从评审到项目的上线；
2. 能够自己独立的完成一个需求的开发。